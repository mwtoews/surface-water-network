# -*- coding: utf-8 -*-
"""Abstract base class for a surface water network for MODFLOW."""

import geopandas
import pickle
import numpy as np
import pandas as pd
from itertools import combinations
from shapely import wkt
from shapely.geometry import LineString, Point, Polygon, box
from shapely.ops import linemerge

from swn.core import SurfaceWaterNetwork
from swn.modflow._misc import (
    transform_data_to_series_or_frame,
    tile_series_as_frame,
)
from swn.spatial import get_sindex, compare_crs


class SwnModflowBase(object):
    """Abstract class for a surface water network adaptor for MODFLOW.

    Attributes
    ----------
    model : flopy.modflow.Modflow or flopy.mf6.ModflowGwf
        Reference to flopy model object.
    reaches : geopandas.GeoDataFrame
        Spatial data generated by this class.
    segments : geopandas.GeoDataFrame
        Copied from swn.segments, but with additional columns added.
    diversions : geopandas.GeoDataFrame, pd.DataFrame or None
        Copied from swn.diversions, if set/defined.
    logger : logging.Logger
        Logger to show messages.

    """

    def __init__(self, logger=None):
        """Initialise SwnModflow.

        Parameters
        ----------
        logger : logging.Logger, optional
            Logger to show messages.
        """
        from importlib.util import find_spec
        if not find_spec("flopy"):
            raise ImportError(self.__class__.__name__ + " requires flopy")
        from swn.logger import get_logger, logging
        if logger is None:
            self.logger = get_logger(self.__class__.__name__)
        elif isinstance(logger, logging.Logger):
            self.logger = logger
        else:
            raise ValueError(
                "expected 'logger' to be Logger; found " + str(type(logger)))
        self.logger.info("creating new %s object", self.__class__.__name__)
        self.segments = None
        self.diversions = None
        self.reaches = None

    def __iter__(self):
        """Return object datasets with an iterator."""
        yield "class", self.__class__.__name__
        yield "model", self.model
        yield "segments", self.segments
        yield "diversions", self.diversions
        yield "reaches", self.reaches

    def __setstate__(self, state):
        """Set object attributes from pickle loads."""
        if not isinstance(state, dict):
            raise ValueError("expected 'dict'; found {!r}".format(type(state)))
        elif "class" not in state:
            raise KeyError("state does not have 'class' key")
        elif state["class"] != self.__class__.__name__:
            raise ValueError("expected state class {!r}; found {!r}"
                             .format(state["class"], self.__class__.__name__))
        self.__init__()
        # Note: model must be set outsie of this method
        self.segments = state["segments"]
        self.diversions = state["diversions"]
        self.reaches = state["reaches"]

    def __getstate__(self):
        """Serialize object attributes for pickle dumps."""
        return dict(self)

    def to_pickle(self, path, protocol=pickle.HIGHEST_PROTOCOL):
        """Pickle (serialize) non-flopy object data to file.

        Parameters
        ----------
        path : str
            File path where the pickled object will be stored.
        protocol : int
            Default is pickle.HIGHEST_PROTOCOL.

        """
        with open(path, "wb") as f:
            pickle.dump(self, f, protocol=protocol)

    @classmethod
    def from_pickle(cls, path, model):
        """Read a pickled format from a file.

        Parameters
        ----------
        path : str
            File path where the pickled object will be stored.
        model : flopy.modflow.Modflow or flopy.mf6.ModflowGwf
            Instance of a flopy MODFLOW model.

        """
        with open(path, "rb") as f:
            obj = pickle.load(f)
        obj.model = model
        return obj

    @property
    def model(self):
        """Return flopy model object."""
        try:
            return getattr(self, "_model", None)
        except AttributeError:
            self.logger.error("'model' property not set")

    @model.setter
    def model(self, model):
        raise NotImplementedError()

    @classmethod
    def from_swn_flopy(
            cls, swn, model, domain_action="freeze",
            reach_include_fraction=0.2):
        """Create a MODFLOW structure from a surface water network.

        Parameters
        ----------
        swn : swn.SurfaceWaterNetwork
            Instance of a SurfaceWaterNetwork.
        model : flopy.modflow.Modflow or flopy.mf6.ModflowGwf
            Instance of a flopy MODFLOW groundwater flow model.
        domain_action : str, optional
            Action to handle IBOUND or IDOMAIN:
                - ``freeze`` : Freeze domain, but clip streams to fit bounds.
                - ``modify`` : Modify domain to fit streams, where possible.
        reach_include_fraction : float or pandas.Series, optional
            Fraction of cell size used as a threshold distance to determine if
            reaches outside the active grid should be included to a cell.
            Based on the furthest distance of the line and cell geometries.
            Default 0.2 (e.g. for a 100 m grid cell, this is 20 m).

        Returns
        -------
        obj
        """
        if cls.__name__ == "SwnModflow":
            domain_label = "ibound"
        elif cls.__name__ == "SwnMf6":
            domain_label = "idomain"
        else:
            raise TypeError("unsupported subclass " + repr(cls))
        if not isinstance(swn, SurfaceWaterNetwork):
            raise ValueError("swn must be a SurfaceWaterNetwork object")
        elif domain_action not in ("freeze", "modify"):
            raise ValueError("domain_action must be one of freeze or modify")
        obj = cls()
        # Attach a few things to the fresh object
        obj.model = model
        obj.segments = swn.segments.copy()
        obj._swn = swn
        # Make sure model CRS and segments CRS are the same (if defined)
        crs = None
        segments_crs = getattr(obj.segments.geometry, "crs", None)
        modelgrid_crs = None
        modelgrid = obj.model.modelgrid
        epsg = modelgrid.epsg
        proj4_str = modelgrid.proj4
        if epsg is not None:
            segments_crs, modelgrid_crs, same = compare_crs(segments_crs, epsg)
        else:
            segments_crs, modelgrid_crs, same = compare_crs(segments_crs,
                                                            proj4_str)
        if (segments_crs is not None and modelgrid_crs is not None and
                not same):
            obj.logger.warning(
                "CRS for segments and modelgrid are different: {0} vs. {1}"
                .format(segments_crs, modelgrid_crs))
        crs = segments_crs or modelgrid_crs
        # Make sure their extents overlap
        minx, maxx, miny, maxy = modelgrid.extent
        model_bbox = box(minx, miny, maxx, maxy)
        rstats = obj.segments.bounds.describe()
        segments_bbox = box(
                rstats.loc["min", "minx"], rstats.loc["min", "miny"],
                rstats.loc["max", "maxx"], rstats.loc["max", "maxy"])
        if model_bbox.disjoint(segments_bbox):
            raise ValueError("modelgrid extent does not cover segments extent")
        # More careful check of overlap of lines with grid polygons
        obj.logger.debug("building model grid cell geometries")
        dis = obj.model.dis
        if domain_label == "ibound":
            domain = obj.model.bas6.ibound[0].array.copy()
            ncol = dis.ncol
            nrow = dis.nrow
        else:
            domain = dis.idomain.array[0].copy()
            ncol = dis.ncol.data
            nrow = dis.nrow.data
        cols, rows = np.meshgrid(np.arange(ncol), np.arange(nrow))
        num_domain_modified = 0
        grid_df = pd.DataFrame({"i": rows.flatten(), "j": cols.flatten()})
        grid_df.set_index(["i", "j"], inplace=True)
        grid_df[domain_label] = domain.flatten()
        if domain_action == "freeze" and (domain == 0).any():
            # Remove any inactive grid cells from analysis
            grid_df = grid_df.loc[grid_df[domain_label] != 0]
        # Determine grid cell size
        col_size = np.median(dis.delr.array)
        if dis.delr.array.min() != dis.delr.array.max():
            obj.logger.warning(
                "assuming constant column spacing %s", col_size)
        row_size = np.median(dis.delc.array)
        if dis.delc.array.min() != dis.delc.array.max():
            obj.logger.warning(
                "assuming constant row spacing %s", row_size)
        cell_size = (row_size + col_size) / 2.0
        # Note: modelgrid.get_cell_vertices(i, j) is slow!
        xv = modelgrid.xvertices
        yv = modelgrid.yvertices
        i, j = [np.array(s[1])
                for s in grid_df.reset_index()[["i", "j"]].iteritems()]
        cell_verts = zip(
            zip(xv[i, j], yv[i, j]),
            zip(xv[i, j + 1], yv[i, j + 1]),
            zip(xv[i + 1, j + 1], yv[i + 1, j + 1]),
            zip(xv[i + 1, j], yv[i + 1, j])
        )
        # Add dataframe of model grid cells to object
        obj.grid_cells = grid_cells = geopandas.GeoDataFrame(
            grid_df, geometry=[Polygon(r) for r in cell_verts], crs=crs)
        # Break up source segments according to the model grid definition
        obj.logger.debug("evaluating reach data on model grid")
        grid_sindex = get_sindex(grid_cells)
        reach_include = swn._segment_series(reach_include_fraction) * cell_size
        # Make an empty DataFrame for reaches
        obj.reaches = pd.DataFrame(columns=["geometry"])
        obj.reaches.insert(1, column="i", value=pd.Series(dtype=int))
        obj.reaches.insert(2, column="j", value=pd.Series(dtype=int))
        empty_reach_df = obj.reaches.copy()  # take this before more added
        obj.reaches.insert(
            1, column="segnum",
            value=pd.Series(dtype=obj.segments.index.dtype))
        obj.reaches.insert(2, column="segndist", value=pd.Series(dtype=float))
        empty_reach_df.insert(3, column="length", value=pd.Series(dtype=float))
        empty_reach_df.insert(4, column="moved", value=pd.Series(dtype=bool))

        # recusive helper function
        def append_reach_df(df, i, j, reach_geom, moved=False):
            if reach_geom.geom_type == "LineString":
                df.loc[len(df.index)] = {
                    "geometry": reach_geom,
                    "i": i,
                    "j": j,
                    "length": reach_geom.length,
                    "moved": moved,
                }
            elif reach_geom.geom_type.startswith("Multi"):
                for sub_reach_geom in reach_geom.geoms:  # recurse
                    append_reach_df(df, i, j, sub_reach_geom, moved)
            else:
                raise NotImplementedError(reach_geom.geom_type)

        # helper function that returns early, if necessary
        def assign_short_reach(reach_df, idx, segnum):
            reach = reach_df.loc[idx]
            reach_geom = reach["geometry"]
            threshold = reach_include[segnum]
            if reach_geom.length > threshold:
                return
            cell_lengths = reach_df.groupby(["i", "j"])["length"].sum()
            this_ij = reach["i"], reach["j"]
            this_cell_length = cell_lengths[this_ij]
            if this_cell_length > threshold:
                return
            grid_geom = grid_cells.at[this_ij, "geometry"]
            # determine if it is crossing the grid once or twice
            grid_points = reach_geom.intersection(grid_geom.exterior)
            split_short = (
                grid_points.geom_type == "Point" or
                (grid_points.geom_type == "MultiPoint" and
                 len(grid_points) == 2))
            if not split_short:
                return
            matches = []
            # sequence scan on reach_df
            for oidx, orch in reach_df.iterrows():
                if oidx == idx or orch["moved"]:
                    continue
                other_ij = orch["i"], orch["j"]
                other_cell_length = cell_lengths[other_ij]
                if (orch["geometry"].distance(reach_geom) < 1e-6 and
                        this_cell_length < other_cell_length):
                    matches.append((oidx, orch["geometry"]))
            if len(matches) == 0:
                # don't merge, e.g. reach does not connect to adjacent cell
                pass
            elif len(matches) == 1:
                # short segment is in one other cell only
                # update new i and j values, keep geometry as it is
                ij1 = tuple(reach_df.loc[matches[0][0], ["i", "j"]])
                reach_df.loc[idx, ["i", "j", "moved"]] = ij1 + (True,)
                # self.logger.debug(
                #    "moved short segment of %s from %s to %s",
                #    segnum, this_ij, ij1)
            elif len(matches) == 2:
                assert grid_points.geom_type == "MultiPoint", grid_points.wkt
                if len(grid_points) != 2:
                    obj.logger.critical(
                        "expected 2 points, found %s", len(grid_points))
                # Build a tiny DataFrame of coordinates for this reach
                reach_c = pd.DataFrame({
                    "pt": [Point(c) for c in reach_geom.coords[:]]
                })
                if len(reach_c) == 2:
                    # If this is a simple line with two coords, split it
                    reach_c.index = [0, 2]
                    reach_c.loc[1] = {
                        "pt": reach_geom.interpolate(0.5, normalized=True)}
                    reach_c.sort_index(inplace=True)
                    reach_geom = LineString(list(reach_c["pt"]))  # rebuild
                # first match assumed to be touching the start of the line
                if reach_c.at[0, "pt"].distance(matches[1][1]) < 1e-6:
                    matches.reverse()
                reach_c["d1"] = reach_c["pt"].apply(
                                lambda p: p.distance(matches[0][1]))
                reach_c["d2"] = reach_c["pt"].apply(
                                lambda p: p.distance(matches[1][1]))
                reach_c["dm"] = reach_c[["d1", "d2"]].min(1)
                # try a simple split where distances switch
                ds = reach_c["d1"] < reach_c["d2"]
                cidx = ds[ds].index[-1]
                # ensure it's not the index of either end
                if cidx == 0:
                    cidx = 1
                elif cidx == len(reach_c) - 1:
                    cidx = len(reach_c) - 2
                i1, j1 = list(reach_df.loc[matches[0][0], ["i", "j"]])
                reach_geom1 = LineString(reach_geom.coords[:(cidx + 1)])
                i2, j2 = list(reach_df.loc[matches[1][0], ["i", "j"]])
                reach_geom2 = LineString(reach_geom.coords[cidx:])
                # update the first, append the second
                reach_df.loc[idx, ["i", "j", "length", "moved"]] = \
                    (i1, j1, reach_geom1.length, True)
                reach_df.at[idx, "geometry"] = reach_geom1
                append_reach_df(reach_df, i2, j2, reach_geom2, moved=True)
                # self.logger.debug(
                #   "split and moved short segment of %s from %s to %s and %s",
                #   segnum, this_ij, (i1, j1), (i2, j2))
            else:
                obj.logger.critical(
                    "unhandled assign_short_reach case with %d matches: %s\n"
                    "%s\n%s", len(matches), matches, reach, grid_points.wkt)

        def assign_remaining_reach(reach_df, segnum, rem):
            if rem.geom_type == "LineString":
                threshold = cell_size * 2.0
                if rem.length > threshold:
                    obj.logger.debug(
                        "remaining line segment from %s too long to merge "
                        "(%.1f > %.1f)", segnum, rem.length, threshold)
                    return
                # search full grid for other cells that could match
                if grid_sindex:
                    bbox_match = sorted(grid_sindex.intersection(rem.bounds))
                    sub = grid_cells.geometry.iloc[bbox_match]
                else:  # slow scan of all cells
                    sub = grid_cells.geometry
                assert len(sub) > 0, len(sub)
                matches = []
                for (i, j), grid_geom in sub.iteritems():
                    if grid_geom.touches(rem):
                        matches.append((i, j, grid_geom))
                if len(matches) == 0:
                    return
                threshold = reach_include[segnum]
                # Build a tiny DataFrame for just the remaining coordinates
                rem_c = pd.DataFrame({
                    "pt": [Point(c) for c in rem.coords[:]]
                })
                if len(matches) == 1:  # merge it with adjacent cell
                    i, j, grid_geom = matches[0]
                    mdist = rem_c["pt"].apply(
                                    lambda p: grid_geom.distance(p)).max()
                    if mdist > threshold:
                        obj.logger.debug(
                            "remaining line segment from %s too far away to "
                            "merge (%.1f > %.1f)", segnum, mdist, threshold)
                        return
                    append_reach_df(reach_df, i, j, rem, moved=True)
                elif len(matches) == 2:  # complex: need to split it
                    if len(rem_c) == 2:
                        # If this is a simple line with two coords, split it
                        rem_c.index = [0, 2]
                        rem_c.loc[1] = {
                            "pt": rem.interpolate(0.5, normalized=True)}
                        rem_c.sort_index(inplace=True)
                        rem = LineString(list(rem_c["pt"]))  # rebuild
                    # first match assumed to be touching the start of the line
                    if rem_c.at[0, "pt"].touches(matches[1][2]):
                        matches.reverse()
                    rem_c["d1"] = rem_c["pt"].apply(
                                    lambda p: p.distance(matches[0][2]))
                    rem_c["d2"] = rem_c["pt"].apply(
                                    lambda p: p.distance(matches[1][2]))
                    rem_c["dm"] = rem_c[["d1", "d2"]].min(1)
                    mdist = rem_c["dm"].max()
                    if mdist > threshold:
                        obj.logger.debug(
                            "remaining line segment from %s too far away to "
                            "merge (%.1f > %.1f)", segnum, mdist, threshold)
                        return
                    # try a simple split where distances switch
                    ds = rem_c["d1"] < rem_c["d2"]
                    cidx = ds[ds].index[-1]
                    # ensure it's not the index of either end
                    if cidx == 0:
                        cidx = 1
                    elif cidx == len(rem_c) - 1:
                        cidx = len(rem_c) - 2
                    i1, j1 = matches[0][0:2]
                    rem1 = LineString(rem.coords[:(cidx + 1)])
                    append_reach_df(reach_df, i1, j1, rem1, moved=True)
                    i2, j2 = matches[1][0:2]
                    rem2 = LineString(rem.coords[cidx:])
                    append_reach_df(reach_df, i2, j2, rem2, moved=True)
                else:
                    obj.logger.critical(
                        "how does this happen? Segments from %d touching %d "
                        "grid cells", segnum, len(matches))
            elif rem.geom_type.startswith("Multi"):
                for sub_rem_geom in rem.geoms:  # recurse
                    assign_remaining_reach(reach_df, segnum, sub_rem_geom)
            else:
                raise NotImplementedError(rem.geom_type)

        # Looping over each segment breaking down into reaches
        for segnum, line in obj.segments.geometry.iteritems():
            remaining_line = line
            if grid_sindex:
                bbox_match = sorted(grid_sindex.intersection(line.bounds))
                if not bbox_match:
                    continue
                sub = grid_cells.geometry.iloc[bbox_match]
            else:  # slow scan of all cells
                sub = grid_cells.geometry
            # Find all intersections between segment and grid cells
            reach_df = empty_reach_df.copy()
            for (i, j), grid_geom in sub.iteritems():
                reach_geom = grid_geom.intersection(line)
                if reach_geom.is_empty or reach_geom.geom_type == "Point":
                    continue
                remaining_line = remaining_line.difference(grid_geom)
                append_reach_df(reach_df, i, j, reach_geom)
            # Determine if any remaining portions of the line can be used
            if line is not remaining_line and remaining_line.length > 0:
                assign_remaining_reach(reach_df, segnum, remaining_line)
            # Reassign short reaches to two or more adjacent grid cells
            # starting with the shortest reach
            reach_lengths = reach_df["length"].loc[
                reach_df["length"] < reach_include[segnum]]
            for idx in list(reach_lengths.sort_values().index):
                assign_short_reach(reach_df, idx, segnum)
            # Potentially merge a few reaches for each i,j of this segnum
            drop_reach_ids = []
            gb = reach_df.groupby(["i", "j"])["geometry"].apply(list)
            for ij, geoms in gb.copy().iteritems():
                i, j = ij
                if len(geoms) > 1:
                    geom = linemerge(geoms)
                    if geom.geom_type == "MultiLineString":
                        # workaround for odd floating point issue
                        geom = linemerge([wkt.loads(g.wkt) for g in geoms])
                    if geom.geom_type == "LineString":
                        sel = ((reach_df["i"] == i) & (reach_df["j"] == j))
                        drop_reach_ids += list(sel.index[sel])
                        obj.logger.debug(
                            "merging %d reaches for segnum %s at %s",
                            sel.sum(), segnum, ij)
                        append_reach_df(reach_df, i, j, geom)
                    elif any(a.distance(b) < 1e-6
                             for a, b in combinations(geoms, 2)):
                        obj.logger.warning(
                            "failed to merge segnum %s at %s: %s",
                            segnum, ij, geom.wkt)
                    # else: this is probably a meandering MultiLineString
            if drop_reach_ids:
                reach_df.drop(drop_reach_ids, axis=0, inplace=True)
            # TODO: Some reaches match multiple cells if they share a border
            # Add all reaches for this segment
            for reach in reach_df.itertuples():
                i = reach.i
                j = reach.j
                reach_geom = reach.geometry
                if line.has_z:
                    # intersection(line) does not preserve Z coords,
                    # but line.interpolate(d) works as expected
                    reach_geom = LineString(line.interpolate(
                        line.project(Point(c))) for c in reach_geom.coords)
                # Get a point from the middle of the reach_geom
                reach_mid_pt = reach_geom.interpolate(0.5, normalized=True)
                reach_record = {
                    "geometry": reach_geom,
                    "segnum": segnum,
                    "segndist": line.project(reach_mid_pt, normalized=True),
                    "i": i,
                    "j": j,
                }
                obj.reaches.loc[len(obj.reaches.index)] = reach_record
                if domain_action == "modify" and domain[i, j] == 0:
                    num_domain_modified += 1
                    domain[i, j] = 1

        if domain_action == "modify":
            if num_domain_modified:
                obj.logger.debug(
                    "updating %d cells from %s array for top layer",
                    num_domain_modified, domain_label.upper())
                if domain_label == "ibound":
                    obj.model.bas6.ibound[0] = domain
                elif domain_label == "idomain":
                    obj.model.dis.idomain.set_data(domain, layer=0)
                obj.reaches = obj.reaches.merge(
                    grid_df[[domain_label]],
                    left_on=["i", "j"], right_index=True)
                obj.reaches.rename(
                    columns={domain_label: "prev_" + domain_label},
                    inplace=True)
            else:
                obj.reaches["prev_" + domain_label] = 1

        # Mark segments that are not used
        obj.segments["in_model"] = True
        outside_model = \
            set(swn.segments.index).difference(obj.reaches["segnum"])
        obj.segments.loc[list(outside_model), "in_model"] = False

        # Evaluate inflow segments that potentially receive flow from outside
        segnums_outside = set(obj.segments[~obj.segments["in_model"]].index)
        if segnums_outside:
            obj.logger.debug(
                "evaluating inflow connections from outside network")
            # Ensure "from_segnums" is always a set
            sel = obj.segments.from_segnums.isna()
            if sel.any():
                obj.segments.loc[sel, "from_segnums"] = \
                    [set() for _ in range(sel.sum())]
            obj.segments["inflow_segnums"] = obj.segments.from_segnums.apply(
                lambda x: x.intersection(segnums_outside))

        # Consider diversions or SW takes, add more reaches
        has_diversions = swn.diversions is not None
        if has_diversions:
            obj.diversions = swn.diversions.copy()
            obj.reaches["diversion"] = False
            obj.reaches["divid"] = obj.diversions.index.dtype.type()
            # Mark diversions that are not used / outside model
            obj.diversions["in_model"] = True
            outside_model = []
            segnum_s = set(obj.reaches.segnum)
            for divid, divn in obj.diversions.iterrows():
                if divn.from_segnum not in segnum_s:
                    # segnum does not exist -- segment is outside model
                    outside_model.append(divid)
            if outside_model:
                obj.diversions.loc[list(outside_model), "in_model"] = False
                obj.logger.debug(
                    "added %d diversions, ignoring %d that did not connect to "
                    "existing segments",
                    obj.diversions["in_model"].sum(), len(outside_model))
            else:
                obj.logger.debug(
                    "added all %d diversions", len(obj.diversions))
            if swn.has_z:
                empty_geom = wkt.loads("linestring z empty")
            else:
                empty_geom = wkt.loads("linestring empty")
            diversions_in_model = obj.diversions[obj.diversions.in_model]
            is_spatial = (
                isinstance(obj.diversions, geopandas.GeoDataFrame) and
                "geometry" in obj.diversions.columns and
                (~diversions_in_model.is_empty).all())
            for divid, divn in diversions_in_model.iterrows():
                # Use the last upstream reach as a template for a new reach
                reach_d = dict(obj.reaches.loc[
                    obj.reaches.segnum == divn.from_segnum].iloc[-1])
                reach_d.update({
                    "segnum": swn.END_SEGNUM,
                    "segndist": 0.0,
                    "diversion": True,
                    "divid": divid,
                    "geometry": empty_geom,
                })
                # Assign one reach at grid cell
                if is_spatial:
                    # Find grid cell nearest to diversion
                    grid_cells = obj.grid_cells
                    grid_sindex = get_sindex(grid_cells)
                    if grid_sindex:
                        bbox_match = sorted(
                            grid_sindex.nearest(divn.geometry.bounds))
                        # more than one nearest can exist! just take one...
                        num_found = len(bbox_match)
                        grid_cell = grid_cells.iloc[bbox_match[0]]
                    else:  # slow scan of all cells
                        sel = grid_cells.intersects(divn.geometry)
                        num_found = sel.sum()
                        grid_cell = grid_cells.loc[sel].iloc[0]
                    if num_found > 1:
                        obj.logger.warning(
                            "%d grid cells are nearest to diversion %r, "
                            "but only taking the first %s",
                            num_found, divid, grid_cell)
                    i, j = grid_cell.name
                    reach_d.update({"i": i, "j": j})
                    if not divn.geometry.is_empty:
                        reach_d["geometry"] = divn.geometry
                obj.reaches.loc[len(obj.reaches) + 1] = reach_d
        else:
            obj.diversions = None

        # Insert k=0, as it is assumed all reaches are on the top layer
        obj.reaches.insert(
            list(obj.reaches.columns).index("i"), column="k", value=0)

        # Now convert from DataFrame to GeoDataFrame
        obj.reaches = geopandas.GeoDataFrame(
                obj.reaches, geometry="geometry", crs=crs)

        # Add information to reaches from segments
        obj.reaches = obj.reaches.merge(
            obj.segments[["sequence"]], "left",
            left_on="segnum", right_index=True)
        # TODO: how to sequence diversions (divid)?
        obj.reaches.sort_values(["sequence", "segndist"], inplace=True)
        del obj.reaches["sequence"]  # segment sequence not used anymore
        # keep "segndist" for interpolation from segment data

        # Add classic ISEG and IREACH, counting from 1
        obj.reaches["iseg"] = 0
        obj.reaches["ireach"] = 0
        iseg = ireach = 0
        prev_segnum = None
        for idx, segnum in obj.reaches["segnum"].iteritems():
            if has_diversions and obj.reaches.at[idx, "diversion"]:
                # Each diversion gets a new segment/reach
                iseg += 1
                ireach = 0
            elif segnum != prev_segnum:
                # Start of a regular segment/reach
                iseg += 1
                ireach = 0
            ireach += 1
            obj.reaches.at[idx, "iseg"] = iseg
            obj.reaches.at[idx, "ireach"] = ireach
            prev_segnum = segnum

        obj.reaches.reset_index(inplace=True, drop=True)
        obj.reaches.index += 1  # flopy series starts at one

        if not hasattr(obj.reaches.geometry, "geom_type"):
            # workaround needed for reaches.to_file()
            obj.reaches.geometry.geom_type = obj.reaches.geom_type

        # each subclass should do more processing with returned object
        return obj

    def set_reach_data_from_segments(
            self, name, value, value_out=None, log10=False):
        """Set reach data based on segment series (or scalar).

        Values are interpolated along lengths of each segment based on a
        "segndist" attribute for segment normalized distance, between 0 and 1.

        Parameters
        ----------
        name : str
            Name for reach dataset.
        value : float or pandas.Series
            Value to assign to the top of each segment. If a float, this value
            is a constant. If a pandas Series, then this is applied for
            each segment.
        value_out : None, float or pandas.Series, optional
            If None (default), the value used for the bottom of outlet segments
            is assumed to be the same as the top. Otherwise, a Series
            for each outlet can be specified.
        log10 : bool, optional
            If True, log-10 transformation applied to interpolation, otherwise
            a linear interpolation is used from start to end of each segment.
        """
        if not isinstance(name, str):
            raise ValueError("'name' must be a str type")
        segdat = self._swn._pair_segment_values(value, value_out, name)
        for segnum, (value1, value2) in segdat.iterrows():
            sel = self.reaches["segnum"] == segnum
            if value1 == value2:
                value = value1
            else:  # interpolate to mid points of each reach from segment data
                segndist = self.reaches.loc[sel, "segndist"]
                if log10:
                    lvalue1 = np.log10(value1)
                    lvalue2 = np.log10(value2)
                    value = 10 ** ((lvalue2 - lvalue1) * segndist + lvalue1)
                else:
                    value = (value2 - value1) * segndist + value1
            self.reaches.loc[sel, name] = value

    def set_reach_data_from_array(self, name, array):
        """Set reach data from an array that matches the model (nrow, ncol).

        Parameters
        ----------
        name : str
            Name for reach dataset.
        array : array_like
            2D array with dimensions (nrow, ncol).
        """
        if not isinstance(name, str):
            raise ValueError("'name' must be a str type")
        elif not hasattr(array, "ndim"):
            raise ValueError("'array' must be array-like")
        elif array.ndim != 2:
            raise ValueError("'array' must have two dimensions")
        dis = self.model.dis
        if self.__class__.__name__ == "SwnModflow":
            expected_shape = dis.nrow, dis.ncol
        elif self.__class__.__name__ == "SwnMf6":
            expected_shape = dis.nrow.data, dis.ncol.data
        else:
            raise TypeError(
                "unsupported subclass " + repr(self.__class__.__name__))
        if expected_shape != array.shape:
            raise ValueError("'array' must have shape (nrow, ncol)")
        self.reaches.loc[:, name] = array[self.reaches["i"], self.reaches["j"]]

    def set_reach_slope(self, method: str = "auto", min_slope=1./1000):
        """Set slope for reaches.

        This method also adds/updates several attributes for reaches.
        The actual data is stored in "slope" for SwnModflow or
        "rgrd" for SwnMf6 classes.

        Parameters
        ----------
        method: str, default "auto"
            Method used to evaluate reach slope.
            - "auto": automatically determine method.
            - "zcoord_ab": if surface water network has Z information,
              use the start/end elevations to determine elevation drop.
            - "grid_top": evaluate the slope from the top grid of the model.
        min_slope : float or pandas.Series, optional
            Minimum downwards slope imposed on segments. If float, then this is
            a global value, otherwise it is per-segment with a Series.
            Default 1./1000 (or 0.001). Diversions (if present) will use the
            minimum of series.
        """
        has_z = self._swn.has_z
        supported_methods = ["auto", "zcoord_ab", "grid_top"]
        if method not in supported_methods:
            raise ValueError(f"{method} not in {supported_methods}")
        if method == "auto":
            if has_z:
                method = "zcoord_ab"
            else:
                method = "grid_top"
        if self.__class__.__name__ == "SwnModflow":
            grid_name = "slope"
        elif self.__class__.__name__ == "SwnMf6":
            grid_name = "rgrd"
        else:
            raise TypeError(
                "unsupported subclass " + repr(self.__class__.__name__))
        self.logger.debug(
            "setting reaches['%s'] with %s method", grid_name, method)
        rchs = self.reaches
        rchs["min_slope"] = np.nan
        self.set_reach_data_from_segments("min_slope", min_slope)
        # with diversions, these reaches will be NaN, so set to min
        sel = rchs.min_slope.isna()
        if sel.any():
            rchs.loc[sel, "min_slope"] = rchs.min_slope[~sel].min()
        rchs[grid_name] = 0.0
        if method == "zcoord_ab":
            if not has_z:
                raise ValueError(
                    f"method {method} requested, but surface water network "
                    "does not contain Z coordinates")

            def get_zcoords(g):
                if g.is_empty or not g.has_z:
                    return []
                elif g.geom_type == "LineString":
                    return [c[2] for c in g.coords[:]]
                elif g.geom_type == "Point":
                    return [g.z]
                elif g.geom_type.startswith("Multi"):
                    # recurse and flatten
                    t = [get_zcoords(sg) for sg in g.geoms]
                    return [item for slist in t for item in slist]
                else:
                    return []

            zcoords = rchs.geometry.apply(get_zcoords)
            rchs["zcoord_count"] = zcoords.apply(len)
            sel = rchs["zcoord_count"] > 0
            if not sel.any():
                self.logger.error(
                    "no reaches selected to determine slope, either because "
                    "they are not LineString or are EMPTY")
            rchs.loc[sel, "zcoord_min"] = zcoords[sel].apply(min)
            rchs.loc[sel, "zcoord_avg"] = \
                zcoords[sel].apply(sum) / rchs.loc[sel, "zcoord_count"]
            rchs.loc[sel, "zcoord_max"] = zcoords[sel].apply(max)
            rchs.loc[sel, "zcoord_first"] = zcoords[sel].apply(lambda z: z[0])
            rchs.loc[sel, "zcoord_last"] = zcoords[sel].apply(lambda z: z[-1])
            # Calculate gradient based on first/last coordinate
            rchs.loc[sel, grid_name] = (
                (rchs.loc[sel, "zcoord_first"] -
                 rchs.loc[sel, "zcoord_last"]) /
                rchs.loc[sel, "geometry"].length
            )
        elif method == "grid_top":
            # Estimate slope from top and grid spacing
            dis = self.model.dis
            col_size = np.median(dis.delr.array)
            row_size = np.median(dis.delc.array)
            px, py = np.gradient(dis.top.array, col_size, row_size)
            grid_slope = np.sqrt(px ** 2 + py ** 2)
            self.set_reach_data_from_array(grid_name, grid_slope)
        # Enforce min_slope
        sel = rchs[grid_name] < rchs["min_slope"]
        if sel.any():
            num = sel.sum()
            self.logger.warning(
                "enforcing min_slope for %d reache%s (%.2f%%)",
                num, "" if num == 1 else "s", 100.0 * num / len(sel))
            rchs.loc[sel, grid_name] = rchs.loc[sel, "min_slope"]

    def _get_segments_inflow(self, data):
        """Get inflow data by gathering external flow upstream of the model.

        This method also adds "inflow_segnums" to segments.

        Parameters
        ----------
        data: dict, pandas.Series or pandas.DataFrame
            Time series of flow for segnums either inside or outside model,
            indexed by segnum.

        Returns
        -------
        pandas.DataFrame
        """
        time_index = self.time_index
        data = transform_data_to_series_or_frame(data, float, time_index)
        data_was_series = isinstance(data, pd.Series)
        if data_was_series:
            data = tile_series_as_frame(data, time_index)
        inflow = pd.DataFrame(dtype=float, index=time_index)

        def return_inflow():
            if data_was_series:
                series = inflow.iloc[0]
                series.name = None
                return series
            else:
                return inflow

        if len(data.columns) == 0:
            self.logger.debug("no data used to determine inflow")
            return return_inflow()
        inflow_segnums_series = pd.Series(
            [set() for _ in range(len(self.segments))], dtype=object,
            index=self.segments.index)
        segnum_s = set(self.segments[self.segments.in_model].index)
        for segd in self.segments.loc[self.segments.in_model].itertuples():
            if not segd.from_segnums:
                continue
            outside_segnums = segd.from_segnums.difference(segnum_s)
            if not outside_segnums:
                continue
            inflow_series = pd.Series(0.0, index=time_index)
            inflow_segnums = set()
            for from_segnum in outside_segnums:
                try:
                    inflow_series += data[from_segnum]
                    inflow_segnums.add(from_segnum)
                except KeyError:
                    self.logger.warning(
                        "flow from segment %s not provided by inflow data "
                        "(needed for segnum %s)", from_segnum, segd.Index)
            if inflow_segnums:
                inflow[segd.Index] = inflow_series
                inflow_segnums_series.at[segd.Index] = inflow_segnums
        num_found = len(inflow.columns)
        if num_found > 0:
            self.logger.info(
                "inflow found for %d segnum%s",
                num_found, "" if num_found == 1 else "s")
            self.segments["inflow_segnums"] = inflow_segnums_series
        else:
            self.logger.info("inflow not found for any segnums")
        return return_inflow()

    def plot(self, column=None, cmap="viridis_r", colorbar=False):
        """
        Show map of reaches with inflow segments in royalblue.

        Parameters
        ----------
        column : str, optional
            Column from reaches to use with "cmap"; default None will actually
            select the reaches.index. See also "legend" to help interpret
            values.
        cmap : str
            Matplotlib color map; default "viridis_r",
        colorbar : bool
            Show colorbar for "column"; default False.

        Returns
        -------
        AxesSubplot

        """
        import matplotlib.pyplot as plt

        fig, ax = plt.subplots()
        ax.set_aspect("equal")

        if column is None:
            reaches = self.reaches[~self.reaches.is_empty].reset_index()
            column = reaches.columns[0]
        else:
            reaches = self.reaches[~self.reaches.is_empty]

        reaches[reaches.geom_type == "LineString"].plot(
            column=column, label="reaches", legend=colorbar, ax=ax, cmap=cmap)

        self.grid_cells.plot(ax=ax, color="whitesmoke", edgecolor="gainsboro")

        def getpt(g, idx):
            if g.geom_type == "LineString":
                return Point(g.coords[idx])
            elif g.geom_type == "Point":
                return g
            else:
                return Point()

        def lastpt(g):
            return getpt(g, -1)

        def firstpt(g):
            return getpt(g, 0)

        reaches_idx = reaches[reaches.segnum.isin(self._swn.outlets)]\
            .groupby(["segnum"]).ireach.idxmax().values
        outlet_pt = reaches.loc[reaches_idx, "geometry"].apply(lastpt)
        outlet_pt.plot(ax=ax, label="outlet", marker="o", color="navy")

        if "inflow_segnums" in self.segments.columns:
            segnums = self.segments.index[
                self.segments.inflow_segnums.map(len) > 0]
            reaches_idx = (
                reaches.segnum.isin(segnums) & (reaches.ireach == 1))
            inflow_pt = reaches.loc[reaches_idx, "geometry"].apply(firstpt)
            inflow_pt.plot(
                ax=ax, label="inflow", marker="P", color="green")

        if self.diversions is not None:
            div_pt = reaches.loc[reaches.diversion, "geometry"].apply(firstpt)
            div_pt.plot(
                ax=ax, label="diversion", marker="D", color="red")

        return ax
